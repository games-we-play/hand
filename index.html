<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hand</title>
  <style>
    body {
      font: 1rem system-ui, sans-serif;
      margin: 3rem auto;
      padding: 0;
      width: 24rem;
    }

    body * {
      font-size: 1rem;
    }

    section,
    form,
    svg {
      line-height: 1.5;
      margin-bottom: 3rem;
    }

    section[lang="zh-CN"] {
      line-height: 1.75;
    }

    section[lang="zh-CN"] i {
      font-style: normal;
      text-emphasis: filled dot;
    }

    form div {
      margin: 0.5rem 0;
    }

    canvas,
    svg {
      border: 1px solid black;
    }

    .buttons {
      text-align: right;
    }

    blockquote,
    .guestbook-message p {
      display: none;
    }
  </style>
</head>

<body>
  <section lang="zh-CN">
    <p>
      <strong>我们手作。</strong>
    </p>
    <p>
      我们写字，我们绘画，我们切削木材、打磨钟表，我们撰写程式、焊接电路。我们不擅长与人打交道，遑论人工智慧。我们喜欢创造性的工作，而非管理。我们拒绝被他人剥夺造物之乐，纵使效率低下，纵使我们的职业被取代。
    </p>
    <p>
      我们将在山中的小木屋完成那未竟的诗篇，<i>要用亲手</i>。
    </p>
  </section>
  <section lang="en">
    <p>
      <strong>We build things by hand.</strong>
    </p>
    <p>
      We write. We paint. We carve wood and polish watches. We solder circuit boards and write codes.
      We are not good at dealing with people, let alone AI. We prefer creative work more than management.
      We refuse to be deprived of the joy of crafting — even if it is inefficient or professionally replaceable.
    </p>
    <p>
      We will finish the unfinished poem in a mountain cabin, <i>with our own hands</i>.
    </p>
  </section>
  <!-- Guestbook Script -->
  <script async src="https://guestbooks.meadow.cafe/resources/js/embed_script/6037/script.js"></script>
  <!-- Guestbook Form -->
  <div id="guestbooks___guestbook-form-container">
    <form id="guestbooks___guestbook-form" action="https://guestbooks.meadow.cafe/guestbook/6037/submit" method="post">
      <div class="guestbooks___input-container">
        <input type="text" id="name" name="name" value="kusa" required hidden>
      </div>
      <div class="guestbooks___input-container">
        <input type="url" id="website" name="website" hidden>
      </div>
      <div id="guestbooks___challenge-answer-container"></div>
      <textarea id="text" name="text" required hidden></textarea>
      <div class="canvas">
        <canvas width="384" height="192"></canvas>
      </div>
      <div id="guestbooks___pow-status"></div>
      <div class="buttons">
        <button id="clear" type="reset">Clear</button>
        <button id="submit" type="submit">Submit</button>
      </div>
      <div id="guestbooks___error-message"></div>
    </form>
  </div>
  <!-- Messages Section -->
  <div id="guestbooks___guestbook-messages-container"></div>
  <!-- Attribution (optional but appreciated!) -->
  <div id="guestbooks___guestbook-made-with">
    Powered by <a href="https://guestbooks.meadow.cafe" target="_blank">Guestbooks</a>
  </div>
  <script src="./pako.min.js"></script>
  <script>
    (() => {
      const text = document.getElementById('text');
      const canvas = document.getElementsByTagName('canvas')[0];
      const ctx = canvas.getContext('2d');
      const strokeWidth = 4;
      const color = 'black';
      const strokes = [];
      let currentStroke = [];
      let drawing = false;

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches?.length) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        return { x: clientX - rect.left, y: clientY - rect.top, t: performance.now() };
      }

      function start(pt) {
        drawing = true;
        currentStroke = [pt];
        draw(pt);
      }

      function draw(pt) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, strokeWidth / 2, 0, Math.PI * 2);
        ctx.fill();
      }

      function addPoint(pt) {
        if (!drawing) return;
        currentStroke.push(pt);
        redraw();
      }

      function end() {
        if (!drawing) return;
        drawing = false;
        if (currentStroke.length) strokes.push(currentStroke);
        currentStroke = [];
        redraw();
        FillToForm();
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = color;
        ctx.fillStyle = color;

        const drawStroke = (s) => {
          if (!s || s.length === 0) return;
          if (s.length === 1) { draw(s[0]); return; }
          ctx.beginPath();
          ctx.moveTo(s[0].x, s[0].y);

          for (let i = 1; i < s.length - 1; i++) {
            const xc = (s[i].x + s[i + 1].x) / 2;
            const yc = (s[i].y + s[i + 1].y) / 2;
            ctx.quadraticCurveTo(s[i].x, s[i].y, xc, yc);
          }
          const last = s[s.length - 1];
          ctx.lineTo(last.x, last.y);
          ctx.stroke();
        };

        for (const s of strokes) drawStroke(s);
        if (currentStroke.length) drawStroke(currentStroke);
      }

      function clear() {
        strokes.length = 0;
        currentStroke = [];
        redraw();
        text.value = '';
      }

      function strokeToPath(s) {
        if (!s || s.length === 0) return '';
        if (s.length === 1)
          return `M ${Math.round(s[0].x)} ${Math.round(s[0].y)} l 0 0`;

        let d = `M ${Math.round(s[0].x)} ${Math.round(s[0].y)}`;
        for (let i = 1; i < s.length - 1; i++) {
          const xc = (s[i].x + s[i + 1].x) / 2;
          const yc = (s[i].y + s[i + 1].y) / 2;
          d += ` Q ${Math.round(s[i].x)} ${Math.round(s[i].y)} ${Math.round(xc)} ${Math.round(yc)}`;
        }
        const last = s[s.length - 1];
        d += ` L ${Math.round(last.x)} ${Math.round(last.y)}`;
        return d;
      }

      function FillToForm() {
        const w = canvas.getBoundingClientRect().width;
        const h = canvas.getBoundingClientRect().height;
        const d = strokes.map(strokeToPath).filter(Boolean).join(' ').trim();
        if (!d) return;
        svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${Math.round(w)}" height="${Math.round(h)}" viewBox="0 0 ${Math.round(w)} ${Math.round(h)}"><path d="${d}" stroke="${color}" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round" /></svg>`;
        text.value = btoa(String.fromCharCode(...pako.gzip(svg)));
        console.log(text.value.length);
      }

      function textToSVG(text) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'image/svg+xml');
        return doc.querySelector('svg');
      }

      canvas.addEventListener('pointerdown', (e) => { canvas.setPointerCapture(e.pointerId); start(getPos(e)); });
      canvas.addEventListener('pointermove', (e) => { if (drawing) addPoint(getPos(e)); });
      canvas.addEventListener('pointerup', (e) => { canvas.releasePointerCapture(e.pointerId); end(); });
      canvas.addEventListener('pointercancel', end);

      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); start(getPos(e)); }, { passive: false });
      canvas.addEventListener('touchmove', (e) => { e.preventDefault(); addPoint(getPos(e)); }, { passive: false });
      canvas.addEventListener('touchend', (e) => { e.preventDefault(); end(); }, { passive: false });

      ctx.scale(1, 1);
      redraw();

      const clearBtn = document.getElementById('clear');
      clearBtn.addEventListener('click', clear);
      const submitBtn = document.getElementById('submit');
      submitBtn.addEventListener('click', () => setTimeout(() => clear(), 1));

      const comments = document.getElementById('guestbooks___guestbook-messages-container');
      const observer = new MutationObserver(() => {
        const blocks = document.getElementsByTagName('blockquote');
        for (const b of blocks) {
          try {
            const compressed = Uint8Array.from(atob(b.innerText), c => c.charCodeAt(0));
            const svg = textToSVG(pako.ungzip(compressed, { to: 'string' }));
            if (svg) {
              b.insertAdjacentElement('afterend', svg);
            }
          } catch { }
        }
      });
      observer.observe(comments, { childList: true });
    })();
  </script>
</body>

</html>